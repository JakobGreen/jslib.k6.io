{"version":3,"file":"s3.min.js","mappings":"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","sources":["webpack://k6-jslib-aws/webpack/bootstrap","webpack://k6-jslib-aws/webpack/runtime/compat get default export","webpack://k6-jslib-aws/webpack/runtime/define property getters","webpack://k6-jslib-aws/webpack/runtime/hasOwnProperty shorthand","webpack://k6-jslib-aws/webpack/runtime/make namespace object","webpack://k6-jslib-aws/external commonjs \"k6/crypto\"","webpack://k6-jslib-aws/external commonjs \"k6/html\"","webpack://k6-jslib-aws/./src/internal/error.ts","webpack://k6-jslib-aws/./src/internal/signature.ts","webpack://k6-jslib-aws/./src/internal/config.ts","webpack://k6-jslib-aws/external commonjs \"k6/http\"","webpack://k6-jslib-aws/./src/internal/s3.ts","webpack://k6-jslib-aws/./src/internal/client.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/crypto\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/html\");","import { parseHTML } from 'k6/html'\n\n/**\n * Base class to derive errors from\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class AWSError extends Error {\n    code: string\n\n    /**\n     * Create an AWSError\n     *\n     * @param {string} message - A longer human readable error message.\n     * @param {string} code - A unique short code representing the error that was emitted\n     */\n    constructor(message: string, code: string) {\n        super(message)\n        this.name = 'AWSError'\n        this.code = code\n    }\n\n    /**\n     * Parse an AWSError from an XML document\n     *\n     * @param  {string} xmlDocument - Serialized XML document to parse the error from\n     */\n    static parseXML(xmlDocument: string): AWSError {\n        const doc = parseHTML(xmlDocument)\n        return new AWSError(doc.find('Message').text(), doc.find('Code').text())\n    }\n}\n","import crypto, { hmac, sha256 } from 'k6/crypto'\nimport { HTTPMethod, HTTPHeaders } from './http'\nimport { AWSConfig } from './config'\nimport { AWSError } from './error'\n\n/**\n * Includes AWS v4 signing information to the provided HTTP headers object.\n *\n * This function will compute the `Authorization` header signature for the\n * provided request components, and add it to `header`. It will do so by following\n * the procedure detailled AWS' API docs: https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n *\n * The resulting `Authorization` header value is computed for the provided\n * headers object. Thus, any modification of the headers past a call to `signHeaders`\n * would effectively invalidate their signature, and the function should be\n * called again to recompute it.\n *\n * @param  {object} headers - HTTP headers request to sign.\n * @param  {number} requestTimestamp - Timestamp of the request\n * @param  {string} method - HTTP method used\n * @param  {string} path - HTTP request URL's path\n * @param  {string} queryString - HTTP request URL's querystring\n * @param  {string | ArrayBuffer} body - HTTP request's payload\n * @param  {AWSConfig} - AWS configuration\n * @param  {string} service - AWS service name\n * @param  {URIEncodingConfig} - URI encoding configuration\n */\nexport function signHeaders(\n    headers: HTTPHeaders,\n    requestTimestamp: number,\n    method: HTTPMethod,\n    path: string,\n    queryString: string,\n    body: string | ArrayBuffer,\n    awsConfig: AWSConfig,\n    service: string,\n    URIencodingConfig: URIEncodingConfig\n): HTTPHeaders {\n    const derivedSigningKey = deriveSigningKey(\n        awsConfig.secretAccessKey,\n        requestTimestamp,\n        awsConfig.region,\n        service\n    )\n\n    const canonicalRequest = createCanonicalRequest(\n        method,\n        path,\n        queryString,\n        headers,\n        body,\n        URIencodingConfig\n    )\n\n    const stringToSign = createStringToSign(\n        requestTimestamp,\n        awsConfig.region,\n        service,\n        sha256(canonicalRequest, 'hex')\n    )\n\n    const credentialScope = createCredentialScope(requestTimestamp, awsConfig.region, service)\n    const signedHeaders = createSignedHeaders(headers)\n    const signature = calculateSignature(derivedSigningKey, stringToSign)\n    const authorizationHeader = `${HashingAlgorithm} Credential=${awsConfig.accessKeyID}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`\n\n    headers['Authorization'] = authorizationHeader\n\n    return headers\n}\n\n/**\n * Error indicating an Invalid signature has been sent to AWS services\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class InvalidSignatureError extends AWSError {\n    /**\n     * Constructs an InvalidSignatureError\n     *\n     * @param  {string} message - human readable error message\n     */\n    constructor(message: string, code: string) {\n        super(message, code)\n        this.name = 'InvalidSignatureError'\n    }\n}\n\n/**\n * Calculte the signature for AWS signature version 4\n *\n * @param  {string} derivedSigningKey - dervied signing key as computed by `deriveSigningKey`\n * @param  {string} stringToSign - String to sign as computed by `createStringToSign`\n * @return {string}\n */\nexport function calculateSignature(derivedSigningKey: ArrayBuffer, stringToSign: string): string {\n    return hmac('sha256', derivedSigningKey, stringToSign, 'hex')\n}\n/**\n * Derives the signing key for authenticating requests signed with\n * the Signature version 4 authentication protocol.\n *\n * deriveSigningKey produces a signing key by creating a series of\n * hash-based message authentication codes (HMACs) represented in\n * a binary format.\n *\n * The derived signing key is specific to the date it's made at, as well as\n * the service and region it targets.\n *\n * @param  {string} secretAccessKey - the AWS secret access key to derive the signing key for\n * @param  {number} time - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service. MUST be UTF-8 encoded.\n * @return {string}\n */\nexport function deriveSigningKey(\n    secretAccessKey: string,\n    time: number,\n    region: string,\n    service: string\n): ArrayBuffer {\n    const kSecret = secretAccessKey\n    const date = toDate(time)\n\n    // FIXME: hmac takes ArrayBuffer as input, but returns bytes (number[]).\n    // How does one convert from one to the other?\n    const kDate: any = hmac('sha256', 'AWS4' + kSecret, date, 'binary')\n    const kRegion: any = hmac('sha256', kDate, region, 'binary')\n    const kService: any = hmac('sha256', kRegion, service, 'binary')\n    const kSigning: any = hmac('sha256', kService, 'aws4_request', 'binary')\n\n    return kSigning\n}\n\n// Hashing Algorithm to use in the signature process\nexport const HashingAlgorithm = 'AWS4-HMAC-SHA256'\n\n/**\n * Certain services, such as S3, allow for unsigned payloads. If\n *  producing a signed canonical request for such service, pass\n *  the `UnsignedPayload` constant value as the payload parameter.\n */\nexport const UnsignedPayload = 'UNSIGNED-PAYLOAD'\n\n/**\n * Create the \"string to sign\" part of the signature Version 4 protocol.\n *\n * The \"string to sign\" includes meta information about your request and\n * about the canonical request that you created with `createCanonicalRequest`.\n * It is used hand in hand with the signing key to create the request signature.\n *\n * @param  {number} requestTimestamp - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service name. MUST be UTF-8 encoded.\n * @param  {string} hashedCanonicalRequest - canonical request as produced by calling the createCanonicalRequest function,\n *     hashed using the SHA256 algorithm (encoded in hexadecimal format).\n * @return {string}\n */\nexport function createStringToSign(\n    requestTimestamp: number,\n    region: string,\n    service: string,\n    hashedCanonicalRequest: string\n): string {\n    // the request date specified in ISO8601 format: YYYYMMDD'T'HHMMSS'Z'\n    const requestDateTime = toTime(requestTimestamp)\n\n    // The credential scope value, consisting of the date in YYYYMMDD format,\n    // the targeted region, the targeted service, and a termination string.\n    // Note that the region and service MUST be UTF-8 encoded.\n    const credentialScope = createCredentialScope(requestTimestamp, region, service)\n\n    const stringToSign = [\n        // Algorithm\n        HashingAlgorithm,\n\n        // RequestDateTime\n        requestDateTime,\n\n        // CredentialScope\n        credentialScope,\n\n        // HashedCanonicalRequest\n        hashedCanonicalRequest,\n    ].join('\\n')\n\n    return stringToSign\n}\n\n/**\n *\n * Helper function creating a credential scope string to use in the signature\n * version 4 process. A credential scope consists of the date of the request\n * in YYYYMMDD format, the targeted region, the targeted service, and a\n * termination string.\n *\n * Note that the region and service MUST be UTF-8 encoded.\n *\n * @param  {number} requestTimestamp - timestamp of the request\n * @param  {string} region - targeted AWS region. MUST be UTF-8 encoded.\n * @param  {string} service - targeted AWS service name. MUST be UTF-8 encoded.\n * @return {string}\n */\nexport function createCredentialScope(\n    requestTimestamp: number,\n    region: string,\n    service: string\n): string {\n    return [toDate(requestTimestamp), region, service, 'aws4_request'].join('/')\n}\n\n/**\n *  Create a string that includes information from your request\n * in a AWS signature v4 standardized (canonical) format.\n *\n * @param  {string} method - the HTTP request method\n * @param  {string} uri - URI-encoded version of the absolute path component of the URI\n * @param  {string} query - request's query string\n * @param  {Object} headers - all the HTTP headers that you wish to include with the signed request\n * @param  {string | ArrayBuffer} payload -  payload to include as the body of the request\n * @param  {URIEncodingConfig} URIencodingConfig- URI encoding configuration\n * @return {string}\n */\nexport function createCanonicalRequest(\n    method: HTTPMethod,\n    uri: string,\n    query: string,\n    headers: HTTPHeaders,\n    payload: string | ArrayBuffer,\n    URIencodingConfig: URIEncodingConfig\n): string {\n    const httpRequestMethod = method.toUpperCase()\n    const canonicalURI = createCanonicalURI(uri, URIencodingConfig)\n    const canonicalQueryString = createCanonicalQueryString(query)\n    const canonicalHeaders = createCanonicalHeaders(headers)\n    const signedHeaders = createSignedHeaders(headers)\n    const requestPayload = createCanonicalPayload(payload)\n\n    const canonicalRequest = [\n        httpRequestMethod,\n        canonicalURI,\n        canonicalQueryString,\n        canonicalHeaders,\n        signedHeaders,\n        requestPayload,\n    ].join('\\n')\n\n    return canonicalRequest\n}\n\n/**\n *  Creates the (canonical) URI-encoded version of the\n *  absolute path component of the URI: everything in the URI\n *  from the HTTP host to the question mark character (\"?\")\n *  that begins the query string parameters (if any).\n *\n * @param  {string} uri - URI to canonize\n * @param  {URIEncodingConfig} - URI encoding configuration\n * @return {string} - canonical URL\n */\nexport function createCanonicalURI(uri: string, URIencodingConfig: URIEncodingConfig): string {\n    if (uri == '/') {\n        return uri\n    }\n\n    let canonicalURI = uri\n    if (uri[uri.length - 1] == '/' && canonicalURI[canonicalURI.length - 1] != '/') {\n        canonicalURI += '/'\n    }\n\n    canonicalURI = URIEncode(canonicalURI, URIencodingConfig.path)\n\n    return URIencodingConfig.double ? URIEncode(canonicalURI, URIencodingConfig.path) : canonicalURI\n}\n\n// FIXME: does it work as expected?\n/**\n * Creates the canonical form of the request's query\n * string. If the request does not include a query string,\n * provide an empty string.\n *\n * @param  {String | Object} qs - query string to canonize\n * @return {string}\n */\nexport function createCanonicalQueryString(qs: string): string {\n    if (qs === '') {\n        return ''\n    }\n\n    // const intermediary: { [key: string]: string } = parseQueryString(qs)\n\n    // return Object.keys(intermediary)\n    //     .sort()\n    //     .map((key: string) => {\n    //         // const values: string[] = Array.isArray(intermediary[key])\n    //         //     ? intermediary[key]\n    //         //     : [intermediary[key]]\n    //         const values = intermediary[key]\n\n    //         return values\n    //             .sort()\n    //             .map((val: string) => encodeURIComponent(key) + '=' + encodeURIComponent(val))\n    //             .join('&')\n    //     })\n    //     .join('&')\n\n    return parseQueryString(qs)\n        .map(([key, value]: [string, string]): string => {\n            return encodeURIComponent(key) + '=' + encodeURIComponent(value)\n        })\n        .join('&')\n}\n/**\n * Create the canonical form of the request's headers.\n * Canonical headers consist of all the HTTP headers you\n * are including with the signed request.\n *\n * Note that:\n *   * for HTTP/1.1 requests, the headers should at least\n * contain the `host` header.\n *   * for HTTP/2, the `:authority` header must be used instead\n * of `host`.\n *\n * @param  {Object} headers\n * @return {string}\n */\nexport function createCanonicalHeaders(headers: HTTPHeaders) {\n    if (headers.constructor !== Object || Object.entries(headers).length === 0) {\n        return ''\n    }\n\n    const canonicalHeaders = Object.entries(headers)\n        .map(([name, values]) => {\n            const canonicalName = name.toLowerCase().trim()\n            const normalizedValues = Array.isArray(values) ? values : [values]\n\n            // Note that we do not need to sort values\n            const canonicalValues = normalizedValues\n                .map((v) => {\n                    // convert sequential spaces to a single space\n                    return v.replace(/\\s+/g, ' ').replace(/^\\s+|\\s+$/g, '')\n                })\n                .join(',') // standard for multiple values in a HTTP header\n\n            return canonicalName + ':' + canonicalValues + '\\n'\n        })\n        .sort()\n        .join('')\n\n    return canonicalHeaders\n}\n\n/**\n * Create the canonical request's signed headers.\n *\n * The signed headers part of the request contains the\n * list of headers included in the request's signing process.\n *\n * Note that:\n *   * for HTTP/1.1 requests, the `host` header must be included.\n *   * for HTTP/2 requests, the `:authority` header must be included instead\n *   of host.\n *   * if used, the `x-amz-date` header must be included.\n *\n * @param  {Object} headers\n * @return {string}\n * @throws {TypeError} - on headers not being an Object, or being empty.\n */\nexport function createSignedHeaders(headers: { [key: string]: string }) {\n    if (headers.constructor !== Object) {\n        throw new TypeError('headers should be an object')\n    }\n\n    if (Object.entries(headers).length === 0) {\n        throw 'headers should at least contain either the Host (HTTP 1.1) or :authority (HTTP 2) parameter'\n    }\n\n    // To create the signed headers list, convert\n    // all header names to lowercase, sort them by\n    // character code, and use a semicolon to separate\n    // the header names.\n    const result = Object.keys(headers)\n        .map((name) => name.toLowerCase().trim())\n        .sort()\n        .join(';')\n\n    return result\n}\n\n/**\n * Create the canonical form of the request's payload.\n *\n * The canonical payload consists in a lowercased, hex encoded,\n * SHA256 hash of the requests body/payload.\n *\n * Certain services, such as S3, allow for unsigned payload. If\n * producing a signed canonical request for such service, pass\n * the `UnsignedPayload` constant value as the payload parameter.\n *\n * @param  {String | ArrayBuffer} payload\n * @return {string}\n */\nexport function createCanonicalPayload(payload: string | ArrayBuffer) {\n    if (payload === UnsignedPayload) {\n        return payload\n    }\n\n    // Note that if the paylaod is null, we convert it\n    // to an empty string.\n    // TODO: Should switching to empty string if null impact headers?\n    return crypto.sha256(payload || '', 'hex').toLowerCase()\n}\n\n/**\n * URIEncodes encodes every bytes of a URI to be URL-safe.\n *\n * This implementation is specific to AWS; who intended to make it as\n * close as possible to the underlying RFC 3946. It:\n *   * URI encode every byte except the unreserved characters: 'A'-'Z', 'a'-'z', '0'-'9',\n *     '-', '.', '_', and '~'.\n *   * considers the space character as a reserved character and must URI encodes\n *     encodes it as \"%20\" (and not as \"+\").\n *   * URI encodes every byte by prefixing with '%' the two-digit hexadecimal value of the byte.\n *   * If the `path` argument is set, forward slashes are not encoded, to fit with\n *     S3 requirements.\n *\n * N.B: this implementation differs with ES6' mainly in that it does\n * encode the \"'\" character.\n *\n * Based on AWS implementation: https://github.com/aws/aws-sdk-java/blob/master/aws-java-sdk-core/src/main/java/com/amazonaws/util/SdkHttpUtils.java#L66\n * Encoding specs: https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html\n *\n * @param {string} uri - uri to encode\n * @param {boolean} path - slash characters should be encoded everywhere,\n *     but in paths, set to false when encoding a path\n * @return {string} the URI encoded result\n */\nexport function URIEncode(uri: string, path: boolean): string {\n    if (uri == '') {\n        return uri\n    }\n\n    return uri\n        .split('') // to be able to map over a string, because... javascript...\n        .map((letter: string) => {\n            if (isAlpha(letter) || isNumeric(letter) || '-._~'.includes(letter)) {\n                return letter\n            }\n\n            // Space should be explicitly encoded to as %20.\n            if (letter == ' ') {\n                return '%20'\n            }\n\n            // If the URI is a path, the forward slash shouldn't\n            // be encoded.\n            if (letter == '/' && path) {\n                return '/'\n            }\n\n            return '%' + letter.charCodeAt(0).toString(16).toUpperCase()\n        })\n        .join('')\n}\n\n/**\n * Class holding URI encoding configuration\n */\nexport class URIEncodingConfig {\n    double: boolean\n    path: boolean\n\n    /**\n     *\n     * @param {boolean} double - should the URI be double encoded?\n     * @param {boolean} path - is the URI a path? If so, its forward\n     *     slashes won't be URIencoded.\n     */\n    constructor(double: boolean, path: boolean) {\n        this.double = double\n        this.path = path\n    }\n}\n\n/**\n * Compute the request time value as specified by the ISO8601\n * format: YYYYMMDD'T'HHMMSS'Z'\n *\n * @param  {number} timestamp\n * @return {string}\n */\nexport function toTime(timestamp: number): string {\n    return new Date(timestamp).toISOString().replace(/[:\\-]|\\.\\d{3}/g, '')\n}\n/**\n * Computethe request date value in the format: YYYMMDD\n *\n * @param  {number} timestamp\n * @return {string}\n */\nexport function toDate(timestamp: number): string {\n    return toTime(timestamp).substring(0, 8)\n}\n\n// FIXME: does it work as expected?\n/**\n * Parse a HTTP request URL's querystring into an object\n * containing its `key=value` pairs.\n *\n * @param  {string} qs\n * @return {object}\n */\nexport function parseQueryString(qs: string): Array<[string, string]> {\n    if (qs.length === 0) {\n        return []\n    }\n\n    return qs\n        .split('&')\n        .filter((e) => e)\n        .map((v: string): [string, string] => {\n            const parts = v.split('=', 2) as [string, string]\n            return [decodeURIComponent(parts[0]), decodeURIComponent(parts[1])]\n        })\n        .sort((a: [string, string], b: [string, string]) => {\n            return a[0].localeCompare(b[0])\n        })\n}\n\nfunction isAlpha(c: string): boolean {\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')\n}\n\nfunction isNumeric(c: string): boolean {\n    return c >= '0' && c <= '9'\n}\n\n// FIXME: finish implementation when needed\n// See the following for more details:\n//   * https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n//   * https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n// export function signQueryString(\n// queryString,\n// requestTimestamp,\n// accessKeyID,\n// secretAccessKey,\n// region,\n// service,\n// ttl, // in seconds\n// headers,\n// doubleURIEncoding = true\n// ) {\n// const credential = [accessKeyID, toDate(requestTimestamp), region, service].join('/')\n//\n// const canonicalRequest = createCanonicalRequest(\n// method,\n// path,\n// queryString,\n// headers,\n// body,\n// doubleURIEncoding\n// )\n//\n// const derivedSigningKey = deriveSigningKey(secretAccessKey, requestTimestamp, region, service)\n//\n// const stringToSign = createStringToSign(\n// requestTimestamp,\n// region,\n// service,\n// sha256(canonicalRequest, 'hex')\n// )\n//\n// const signedHeaders = createSignedHeaders(headers)\n// const signature = calculateSignature(derivedSigningKey, stringToSign)\n//\n// return [\n// `X-Amz-Algorithm=${HashingAlgorithm}`,\n// `X-Amz-Credential=${crediental}`,\n// `X-Amz-Date=${toTime(requestTimestamp)}`,\n// `X-Amz-Expires=${ttl}`,\n// `X-Amz-SignedHeaders=${signedHeaders}`,\n// `X-Amz-Signature=${signature}`,\n//`X-Amz-Security-Token=`,  // TODO: optional\n// ].join('&')\n// }\n","/** Class holding an AWS connection information */\nexport class AWSConfig {\n    region: string\n    accessKeyID: string\n    secretAccessKey: string\n\n    /**\n     * Create an AWSConfig.\n     *\n     * @param {string} region - the AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     * @param {string} accessKeyID - Your user's AWS access key id credential\n     * @param {string} secretAccessKey - Your user's AWS secret access key credential\n     * @throws {InvalidArgumentException}\n     */\n    constructor(region: string, accessKeyID: string, secretAccessKey: string) {\n        if (typeof region !== 'string' || region === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS region; reason: should be a non empty string'\n            )\n        }\n\n        if (typeof accessKeyID !== 'string' || accessKeyID === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS access key ID; reason: should be a non empty string'\n            )\n        }\n\n        if (typeof secretAccessKey !== 'string' || secretAccessKey === '') {\n            throw new InvalidAWSConfigError(\n                'invalid AWS secret access key; reason: should be a non empty string'\n            )\n        }\n\n        this.region = region\n        this.accessKeyID = accessKeyID\n        this.secretAccessKey = secretAccessKey\n    }\n}\n\n/** Class representing an invalid AWS configuration */\nexport class InvalidAWSConfigError extends Error {\n    constructor(message: string) {\n        super(message)\n    }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/http\");","import { bytes } from 'k6'\nimport http from 'k6/http'\nimport { parseHTML } from 'k6/html'\nimport { sha256 } from 'k6/crypto'\n\nimport { InvalidSignatureError, URIEncodingConfig } from './signature'\nimport { AWSClient, AWSRequest } from './client'\nimport { AWSError } from './error'\nimport { AWSConfig } from './config'\n\n/** Class allowing to interact with Amazon AWS's S3 service */\nexport class S3Client extends AWSClient {\n    /**\n     * Create a S3Client\n     *\n     * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     */\n    constructor(awsConfig: AWSConfig) {\n        const URIencodingConfig = new URIEncodingConfig(false, true)\n        super(awsConfig, 's3', URIencodingConfig)\n    }\n\n    /**\n     * Returns a list of all buckets owned by the authenticated sender of the request.\n     * To use this operation, you must have the s3:ListAllMyBuckets permission.\n     *\n     * @return  {Array.<S3Bucket>} buckets - An array of objects describing S3 buckets\n     *     with the following fields: name, and creationDate.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    listBuckets(): Array<S3Bucket> {\n        // Prepare request\n        const method = 'GET'\n        const host = `${this.serviceName}.${this.awsConfig.region}.amazonaws.com`\n        const body = ''\n        const signedRequest: AWSRequest = super.buildRequest(method, host, '/', '', body, {\n            'X-Amz-Content-SHA256': sha256(body, 'hex'),\n        })\n\n        const res = http.request(method, signedRequest.url, body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(res.error_code, res.error, res.body as string)\n\n        let buckets: Array<S3Bucket> = []\n\n        const doc = parseHTML(res.body as string)\n\n        doc.find('Buckets')\n            .children()\n            .each((_, bucketDefinition) => {\n                let bucket = {}\n\n                bucketDefinition.children().forEach((child) => {\n                    switch (child.nodeName()) {\n                        case 'name':\n                            Object.assign(bucket, { name: child.textContent() })\n                            break\n                        case 'creationdate':\n                            Object.assign(bucket, {\n                                creationDate: Date.parse(child.textContent()),\n                            })\n                    }\n                })\n\n                buckets.push(bucket as S3Bucket)\n            })\n\n        return buckets\n    }\n\n    /**\n     * Returns some or all (up to 1,000) of the objects in a bucket.\n     *\n     * @param  {string} bucketName - Bucket name to list.\n     * @param  {string?} prefix='' - Limits the response to keys that begin with the specified prefix.\n     * @return {Array.<S3Object>} - returns an array of objects describing S3 objects\n     *     with the following fields: key, lastModified, etag, size and storageClass.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    listObjects(bucketName: string, prefix?: string): Array<S3Object> {\n        // Prepare request\n        const method = 'GET'\n        const host = `${bucketName}.${this.serviceName}.${this.awsConfig.region}.amazonaws.com`\n        const body = ''\n        const signedRequest: AWSRequest = super.buildRequest(\n            method,\n            host,\n            '/',\n            'list-type=2',\n            body,\n            {\n                'X-Amz-Content-SHA256': sha256(body, 'hex'),\n            }\n        )\n\n        const res = http.request(method, signedRequest.url, body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(res.error_code, res.error, res.body as string)\n\n        let objects: Array<S3Object> = []\n\n        // Extract the objects definition from\n        // the XML response\n        parseHTML(res.body as string)\n            .find('Contents')\n            .each((_, objectDefinition) => {\n                let obj = {}\n\n                objectDefinition.children().forEach((child) => {\n                    switch (child.nodeName()) {\n                        case 'key':\n                            Object.assign(obj, { key: child.textContent() })\n                            break\n                        case 'lastmodified':\n                            // const parsed = Date.parse(\n                            //     child.textContent(),\n                            //     'YYYY-MM-ddTHH:mm:ss.sssZ'\n                            // )\n                            Object.assign(obj, { lastModified: Date.parse(child.textContent()) })\n                            break\n                        case 'etag':\n                            Object.assign(obj, { etag: child.textContent() })\n                            break\n                        case 'size':\n                            Object.assign(obj, { size: parseInt(child.textContent()) })\n                            break\n                        case 'storageclass':\n                            Object.assign(obj, { storageClass: child.textContent() })\n                    }\n                })\n\n                objects.push(obj as S3Object)\n            })\n\n        return objects\n    }\n    /**\n     * Retrieves an Object from Amazon S3.\n     *\n     * To use getObject, you must have `READ` access to the object.\n     *\n     * @param  {string} bucketName - The bucket name containing the object.\n     * @param  {string} objectKey - Key of the object to get.\n     * @return {S3Object} - returns the content of the fetched S3 Object.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    getObject(bucketName: string, objectKey: string): S3Object {\n        // Prepare request\n        const method = 'GET'\n        const host = `${bucketName}.${this.serviceName}.${this.awsConfig.region}.amazonaws.com`\n        const path = `/${objectKey}`\n        const body = ''\n        const signedRequest: AWSRequest = super.buildRequest(method, host, path, '', body, {\n            'X-Amz-Content-SHA256': sha256(body, 'hex'),\n        })\n\n        const res = http.request(method, signedRequest.url, body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(res.error_code, res.error, res.body as string)\n\n        return new S3Object(\n            objectKey,\n            Date.parse(res.headers['Last-Modified']),\n            res.headers['ETag'],\n            parseInt(res.headers['Content-Length']),\n            undefined, // GetObject response doesn't contain the storage class\n            res.body\n        )\n    }\n    /**\n     * Adds an object to a bucket.\n     *\n     * You must have WRITE permissions on a bucket to add an object to it.\n     *\n     * @param  {string} bucketName - The bucket name containing the object.\n     * @param  {string} objectKey - Key of the object to put.\n     * @param  {string | ArrayBuffer} data - the content of the S3 Object to upload.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    putObject(bucketName: string, objectKey: string, data: string | ArrayBuffer) {\n        // Prepare request\n        const method = 'PUT'\n        const host = `${bucketName}.${this.serviceName}.${this.awsConfig.region}.amazonaws.com`\n        const path = `/${objectKey}`\n        const queryString = ''\n        const body = data\n        const signedRequest: AWSRequest = super.buildRequest(\n            method,\n            host,\n            path,\n            queryString,\n            body,\n            {\n                'X-Amz-Content-SHA256': sha256(body, 'hex'),\n            }\n        )\n\n        const res = http.request(method, signedRequest.url, body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(res.error_code, res.error, res.body as string)\n    }\n\n    /**\n     * Removes the null version (if there is one) of an object and inserts a delete marker,\n     * which becomes the latest version of the object.\n     *\n     * @param  {string} bucketName - The bucket name containing the object.\n     * @param  {string} objectKey - Key of the object to delete.\n     * @throws  {S3ServiceError}\n     * @throws  {InvalidSignatureError}\n     */\n    deleteObject(bucketName: string, objectKey: string): void {\n        // Prepare request\n        const method = 'DELETE'\n        const host = `${bucketName}.${this.serviceName}.${this.awsConfig.region}.amazonaws.com`\n        const path = `/${objectKey}`\n        const queryString = ''\n        const body = ''\n        const signedRequest: AWSRequest = super.buildRequest(\n            method,\n            host,\n            path,\n            queryString,\n            body,\n            {\n                'X-Amz-Content-SHA256': sha256(body, 'hex'),\n            }\n        )\n\n        const res = http.request(method, signedRequest.url, body, {\n            headers: signedRequest.headers,\n        })\n        this._handle_error(res.error_code, res.error, res.body as string)\n    }\n\n    // FIXME: remove dependency to `error_message`\n    // FIXME: just pass it the response?\n    _handle_error(error_code: number, error_message: string, error_body: string) {\n        if (error_message == '' || error_code === 0) {\n            return\n        }\n\n        // FIXME: should be error_code === 1301 instead\n        // See: https://github.com/grafana/k6/issues/2474\n        // See: https://github.com/golang/go/issues/49281\n        if (error_message && error_message.startsWith('301')) {\n            // Bucket not found\n            throw new S3ServiceError('Resource not found', 'ResourceNotFound', 'getObject')\n        }\n\n        const awsError = AWSError.parseXML(error_body)\n        switch (awsError.code) {\n            case 'AuthorizationHeaderMalformed':\n                throw new InvalidSignatureError(awsError.message, awsError.code)\n            default:\n                throw new S3ServiceError(awsError.message, awsError.code, 'listObjects')\n        }\n    }\n}\n\n// TODO: use interface instead?\n/** Class representing a S3 Bucket */\nexport class S3Bucket {\n    name: string\n    creationDate: Date\n\n    /**\n     * Create an S3 Bucket\n     *\n     * @param  {string} name - S3 bucket's name\n     * @param  {Date} creationDate - S3 bucket's creation date\n     */\n    constructor(name: string, creationDate: Date) {\n        this.name = name\n        this.creationDate = creationDate\n    }\n}\n\n// TODO: use interface instead?\n/** Class representing an S3 Object */\nexport class S3Object {\n    key: string\n    lastModified: number\n    etag: string\n    size: number\n    storageClass: StorageClass\n    data?: string | bytes | null\n\n    /**\n     * Create an S3 Object\n     *\n     * @param  {string} key - S3 object's key\n     * @param  {Date} lastModified - S3 object last modification date\n     * @param  {string} etag - S3 object's etag\n     * @param  {number} size - S3 object's size\n     * @param  {StorageClass} storageClass - S3 object's storage class\n     * @param  {string | bytes | null} data=null - S3 Object's data\n     */\n    constructor(\n        key: string,\n        lastModified: number,\n        etag: string,\n        size: number,\n        storageClass: StorageClass,\n        data?: string | bytes | null\n    ) {\n        this.key = key\n        this.lastModified = lastModified\n        this.etag = etag\n        this.size = size\n        this.storageClass = storageClass\n        this.data = data\n    }\n}\n\n/**\n * Error indicating a S3 operation failed\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class S3ServiceError extends AWSError {\n    operation: string\n\n    /**\n     * Constructs a S3ServiceError\n     *\n     * @param  {string} message - human readable error message\n     * @param  {string} code - A unique short code representing the error that was emitted\n     * @param  {string} operation - Name of the failed Operation\n     */\n    constructor(message: string, code: string, operation: string) {\n        super(message, code)\n        this.name = 'S3ServiceError'\n        this.operation = operation\n    }\n}\n\n/**\n * Describes the class of storage used to store a S3 object.\n */\ntype StorageClass =\n    | 'STANDARD'\n    | 'REDUCED_REDUNDANCY'\n    | 'GLACIER'\n    | 'STANDARD_IA'\n    | 'INTELLIGENT_TIERING'\n    | 'DEEP_ARCHIVE'\n    | 'OUTPOSTS'\n    | 'GLACIER_IR'\n    | undefined\n","import { HTTPMethod, HTTPHeaders } from './http'\nimport { AWSConfig } from './config'\nimport { signHeaders, URIEncodingConfig, toTime } from './signature'\n\n/**\n * Class allowing to build requests targeting AWS APIs\n *\n * This class is meant to be used as a base class for specific\n * services clients. See S3Client or SecretsManagerClient for\n * usage examples.\n */\nexport class AWSClient {\n    awsConfig: AWSConfig\n    serviceName: string\n    URIencodingConfig: URIEncodingConfig\n\n    /**\n     * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     * @param  {string} serviceName - name of the service to target.\n     * @param  {URIEncodingConfig} URIencodingConfig - configures how requests URIs should be encoded.\n     */\n    constructor(awsConfig: AWSConfig, serviceName: string, URIencodingConfig: URIEncodingConfig) {\n        this.awsConfig = awsConfig\n        this.serviceName = serviceName\n        this.URIencodingConfig = URIencodingConfig\n    }\n\n    buildRequest(\n        method: HTTPMethod,\n        host: string,\n        path: string,\n        queryString: string,\n        body: string | ArrayBuffer,\n        headers: HTTPHeaders\n    ): AWSRequest {\n        const requestTimestamp: number = Date.now()\n        const date: string = toTime(requestTimestamp)\n\n        headers['Host'] = host\n        headers['X-Amz-Date'] = date\n\n        headers = signHeaders(\n            // headers\n            headers,\n\n            // requestTimestamp\n            requestTimestamp,\n\n            // method\n            method,\n\n            // path\n            path,\n\n            // querystring\n            queryString,\n\n            // body\n            body,\n\n            // AWS configuration\n            this.awsConfig,\n\n            // AwS target service name\n            this.serviceName,\n\n            // doubleEncoding: S3 does single-encoding of the uri component\n            // pathURIEncoding: S3 manipulates object keys, and forward slashes\n            // shouldn't be URI encoded\n            this.URIencodingConfig\n        )\n\n        // '?' should not be part of the querystring when we sign the headers\n        path = path !== '' ? path : '/'\n        let url = `https://${host}${path}`\n        if (queryString !== '') {\n            url += `?${queryString}`\n        }\n\n        return { url: url, headers: headers }\n    }\n}\n\n/**\n * Type alias representing the result of an AWSClient.buildRequest call\n */\nexport interface AWSRequest {\n    url: string\n    headers: HTTPHeaders\n}\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","AWSError","message","code","name","xmlDocument","doc","parseHTML","find","text","Error","signHeaders","headers","requestTimestamp","method","path","queryString","body","awsConfig","service","URIencodingConfig","derivedSigningKey","secretAccessKey","time","region","kSecret","date","toDate","kDate","hmac","kRegion","kService","deriveSigningKey","canonicalRequest","uri","query","payload","httpRequestMethod","toUpperCase","canonicalURI","length","URIEncode","createCanonicalURI","canonicalQueryString","qs","split","filter","e","map","v","parts","decodeURIComponent","sort","b","localeCompare","parseQueryString","encodeURIComponent","join","createCanonicalQueryString","canonicalHeaders","constructor","entries","values","toLowerCase","trim","Array","isArray","replace","createCanonicalHeaders","signedHeaders","createSignedHeaders","requestPayload","UnsignedPayload","crypto","createCanonicalPayload","createCanonicalRequest","stringToSign","hashedCanonicalRequest","requestDateTime","toTime","credentialScope","createCredentialScope","HashingAlgorithm","createStringToSign","sha256","signature","calculateSignature","authorizationHeader","accessKeyID","InvalidSignatureError","TypeError","keys","letter","c","isNumeric","includes","charCodeAt","toString","URIEncodingConfig","double","this","timestamp","Date","toISOString","substring","AWSConfig","InvalidAWSConfigError","S3Client","host","serviceName","signedRequest","res","http","url","_handle_error","error_code","error","buckets","children","each","_","bucketDefinition","bucket","forEach","child","nodeName","assign","textContent","creationDate","parse","push","bucketName","prefix","objects","objectDefinition","lastModified","etag","size","parseInt","storageClass","objectKey","S3Object","undefined","data","error_message","error_body","startsWith","S3ServiceError","awsError","parseXML","now","S3Bucket","operation"],"sourceRoot":""}